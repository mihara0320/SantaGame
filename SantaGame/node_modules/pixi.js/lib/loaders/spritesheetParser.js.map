{"version":3,"sources":["../../src/loaders/spritesheetParser.js"],"names":["spritesheetParser","resource","next","resourcePath","imageResourceName","name","data","isJson","frames","resources","loadOptions","crossOrigin","loadType","LOAD_TYPE","IMAGE","metadata","imageMetadata","isDataUrl","meta","image","dirname","url","replace","baseUrl","add","onImageLoad","res","textures","frameKeys","Object","keys","baseTexture","texture","resolution","core","utils","getResolutionOfUrl","scale","undefined","update","batchIndex","processFrames","initialFrameIndex","maxFrames","frameIndex","length","i","rect","frame","trim","orig","Rectangle","sourceSize","w","h","rotated","x","y","trimmed","spriteSourceSize","Texture","TextureCache","shouldProcessNextBatch","BATCH_SIZE","processNextBatch","done","setTimeout","iteration"],"mappings":"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","file":"spritesheetParser.js","sourcesContent":["import { Resource } from 'resource-loader';\nimport path from 'path';\nimport * as core from '../core';\n\nconst BATCH_SIZE = 1000;\n\nexport default function ()\n{\n    return function spritesheetParser(resource, next)\n    {\n        let resourcePath;\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data || !resource.isJson || !resource.data.frames || this.resources[imageResourceName])\n        {\n            next();\n\n            return;\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            loadType: Resource.LOAD_TYPE.IMAGE,\n            metadata: resource.metadata.imageMetadata,\n        };\n\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            resourcePath = resource.data.meta.image;\n        }\n        else\n        {\n            resourcePath = `${path.dirname(resource.url.replace(this.baseUrl, ''))}/${resource.data.meta.image}`;\n        }\n\n        // load the image for this sheet\n        this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res)\n        {\n            resource.textures = {};\n\n            const frames = resource.data.frames;\n            const frameKeys = Object.keys(frames);\n            const baseTexture = res.texture.baseTexture;\n            let resolution = core.utils.getResolutionOfUrl(resource.url);\n            const scale = resource.data.meta.scale;\n\n            // for now (to keep things compatible) resolution overrides scale\n            // Support scale field on spritesheet\n            if (resolution === 1 && scale !== undefined && scale !== 1)\n            {\n                baseTexture.resolution = resolution = scale;\n                baseTexture.update();\n            }\n\n            let batchIndex = 0;\n\n            function processFrames(initialFrameIndex, maxFrames)\n            {\n                let frameIndex = initialFrameIndex;\n\n                while (frameIndex - initialFrameIndex < maxFrames && frameIndex < frameKeys.length)\n                {\n                    const i = frameKeys[frameIndex];\n                    const rect = frames[i].frame;\n\n                    if (rect)\n                    {\n                        let frame = null;\n                        let trim = null;\n                        const orig = new core.Rectangle(\n                            0,\n                            0,\n                            frames[i].sourceSize.w / resolution,\n                            frames[i].sourceSize.h / resolution\n                        );\n\n                        if (frames[i].rotated)\n                        {\n                            frame = new core.Rectangle(\n                                rect.x / resolution,\n                                rect.y / resolution,\n                                rect.h / resolution,\n                                rect.w / resolution\n                            );\n                        }\n                        else\n                        {\n                            frame = new core.Rectangle(\n                                rect.x / resolution,\n                                rect.y / resolution,\n                                rect.w / resolution,\n                                rect.h / resolution\n                            );\n                        }\n\n                        //  Check to see if the sprite is trimmed\n                        if (frames[i].trimmed)\n                        {\n                            trim = new core.Rectangle(\n                                frames[i].spriteSourceSize.x / resolution,\n                                frames[i].spriteSourceSize.y / resolution,\n                                rect.w / resolution,\n                                rect.h / resolution\n                            );\n                        }\n\n                        resource.textures[i] = new core.Texture(\n                            baseTexture,\n                            frame,\n                            orig,\n                            trim,\n                            frames[i].rotated ? 2 : 0\n                        );\n\n                        // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n                        core.utils.TextureCache[i] = resource.textures[i];\n                    }\n\n                    frameIndex++;\n                }\n            }\n\n            function shouldProcessNextBatch()\n            {\n                return batchIndex * BATCH_SIZE < frameKeys.length;\n            }\n\n            function processNextBatch(done)\n            {\n                processFrames(batchIndex * BATCH_SIZE, BATCH_SIZE);\n                batchIndex++;\n                setTimeout(done, 0);\n            }\n\n            function iteration()\n            {\n                processNextBatch(() =>\n                {\n                    if (shouldProcessNextBatch())\n                    {\n                        iteration();\n                    }\n                    else\n                    {\n                        next();\n                    }\n                });\n            }\n\n            if (frameKeys.length <= BATCH_SIZE)\n            {\n                processFrames(0, BATCH_SIZE);\n                next();\n            }\n            else\n            {\n                iteration();\n            }\n        });\n    };\n}\n"]}